package database_service

import (
	"context"
	"strconv"
	"time"

	"github.com/bwmarrin/discordgo"
)

// FetchDiscordUsername returns the username of a user in a guild.
// Preference is to use the guild member endpoint to ensure presence in the server.
func FetchDiscordUsername(ctx context.Context, s *discordgo.Session, guildID string, userID string) (string, error) {
	// discordgo does not take context; create a blocking call with a wrapper
	member, err := s.GuildMember(guildID, userID)
	if err != nil {
		// fallback to global user fetch (not guaranteed to be in guild)
		u, uerr := s.User(userID)
		if uerr != nil {
			return "", err
		}
		return u.Username, nil
	}
	if member != nil && member.User != nil && member.User.Username != "" {
		return member.User.Username, nil
	}
	// final fallback
	u, err := s.User(userID)
	if err != nil {
		return "", err
	}
	return u.Username, nil
}

// CreateUserForDiscordID looks up a Discord username and persists a user row.
// The UUID primary key is generated by Postgres (uuid-ossp) default on insert.
func (db *DB) CreateUserForDiscordID(ctx context.Context, actor string, s *discordgo.Session, guildID string, discordUserID string) (User, error) {
	username, err := FetchDiscordUsername(ctx, s, guildID, discordUserID)
	if err != nil {
		return User{}, err
	}
	idInt, err := strconv.ParseInt(discordUserID, 10, 64)
	if err != nil {
		return User{}, err
	}
	return db.UpsertUser(ctx, actor, User{
		DiscordUserID:   idInt,
		DiscordUsername: username,
	})
}

// CreateOrRotateLoginTokenForDiscordUser fetches username, ensures the user exists,
// revokes previous active tokens, and creates a new 15-minute token.
func (db *DB) CreateOrRotateLoginTokenForDiscordUser(ctx context.Context, actor string, s *discordgo.Session, guildID string, discordUserID string) (LoginToken, error) {
	username, err := FetchDiscordUsername(ctx, s, guildID, discordUserID)
	if err != nil {
		return LoginToken{}, err
	}
	idInt, err := strconv.ParseInt(discordUserID, 10, 64)
	if err != nil {
		return LoginToken{}, err
	}

	// Ensure user exists or is updated
	user, err := db.UpsertUser(ctx, actor, User{DiscordUserID: idInt, DiscordUsername: username})
	if err != nil {
		return LoginToken{}, err
	}

	// Rotate token transactionally
	tx, err := db.pool.Begin(ctx)
	if err != nil {
		return LoginToken{}, err
	}
	defer func() { _ = tx.Rollback(ctx) }()
	if err := withActor(ctx, tx, actor); err != nil {
		return LoginToken{}, err
	}

	// revoke existing non-expired tokens for this user
	if _, err := tx.Exec(ctx, `UPDATE login_tokens SET revoked = true WHERE user_id = $1 AND revoked = false AND expires_at > now()`, user.ID); err != nil {
		return LoginToken{}, err
	}

	// create new token lasting 15 minutes
	var out LoginToken
	row := tx.QueryRow(ctx, `
        INSERT INTO login_tokens (user_id, token, added_at, expires_at)
        VALUES ($1, uuid_generate_v4(), now(), now() + interval '15 minutes')
        RETURNING id, user_id, token, added_at, expires_at, revoked
    `, user.ID)
	if err := row.Scan(&out.ID, &out.UserID, &out.Token, &out.AddedAt, &out.ExpiresAt, &out.Revoked); err != nil {
		return LoginToken{}, err
	}
	if err := tx.Commit(ctx); err != nil {
		return LoginToken{}, err
	}
	// sanity: ensure duration ~15m (not required, but helpful)
	_ = time.Minute // keep import if unused by build tags elsewhere
	return out, nil
}
